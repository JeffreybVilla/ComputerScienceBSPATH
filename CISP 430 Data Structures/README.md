# DSAFINALREVIEW2020


## SORTING
1.	Be familiar with Bubblesort, insertionsort, and selectionsort, how they work, and their time complexities.
2.	Be familiar with mergesort, quicksort, and heapsort and be able to hand execute these algorithms.
3.	Be able to write pseudocode to combine several of the sorting algorithms we have studied into one hybrid algorithm.


## COMPLEXITY & BIG O
1.	Know the value of time complexity analysis and be able to explain why we use it.
2.	Know the common BigO time complexities, the shape of their curves, and their rankings from good to bad.
3.	Given a BigO time complexity, provide a pseudocode algorithm that has that time complexity.
4.	Know how to apply the 3 methods for determining time complexity: empirical, math analysis, and code “rules of thumb”.
5.	Be familiar with the simple mathematical series done in this class and their code implementations.


## RECURSION
1.	Know how to do recursive hand executions with all the boxes. Be able to use the SHAPE of the resulting diagrams to determine time complexity.
2.	Know the general algorithm used in Queens and Maze and be able to produce a pseudocode variation of this algorithm for a new problem you have never seen before.
3.	Be able to hand execute algorithms similar to Queens and Maze, having recursive calls from INSIDE a loop or other control structure.
4.	Be familiar with the data representations in the Queens and Maze implementations and be able to produce variations of these representations.
5.	Be familiar with the various recursive examples from the “class notes” and be able to hand execute them.


## CONTAINERS
1.	Know the basics of linked lists and self-referential nodes. Be able to write pseudocode variations of common linked list algorithms like traverse and push, deque, priority_insert, etc.
2.	Be able to draw linked list diagrams for a variety of structures.


## STACK & QUEUE ALGORITHMS
1.	Be familiar with the stack and queue algorithms from the “class notes” and be able to hand execute them.
2.	Be able to write a simple pseudocode algorithm that uses a stack and/or a queue to perform some simple task, like identify a palindrome, reverse an expression, etc.


## TREES
1.	Know the advantages and disadvantages of trees.
2.	Be able to perform hand executions of insertions into binary search trees and AVL trees. 
3.	Be able to perform hand executions into B-Trees of any order.
4.	Be able to diagram a recursive tree traversal using preorder, inorder, and postorder.

## HASHING
1.	Understand the basic concept of hashing and WHY it is super-efficient.
2.	Be able to hand execute hashing insertions and resolve any collisions via stepping, chaining, or rehashing.
3.	Be able to generate a perfect hash (no collisions) for a given set of keys.
4.	Know the difference between a table-driven-hash and an algorithmic-hash and the tradeoffs between the 2 methods.


## GRAPHS
1.	Be able to convert between a graph diagram and its internal memory representation and vice versa and understand the tradeoffs between table and list representations.
2.	Given a graph, be able to generate a minimum spanning tree, or least-cost forwarding tables using Prim’s, OSPF, and RIP.


## NEURAL NETS
1.	Know the Neural Net Stuff.


## FINITE ELEMENT ANALYSIS
2.	Understand the basics concepts use in the Finite Element Analysis (FEA) implementation.
